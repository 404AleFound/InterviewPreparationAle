# 项目描述
## 1 项目背景
本项目为同济大学土木工程学院结构韧性评价任务开发，专注于实现轻量级JSON数据解析与序列化功能。项目不依赖任何第三方库，完全基于 C++ 标准模板库 (STL) 实现，具备良好的可移植性与简洁性。

韧性评价任务该任务以“地震作用下建筑功能的可恢复能力”为目标，把建筑拆解到构件/子系统层级，综合考虑构件重要性（对整体功能的影响权重）、构件承载与抗震性能（强度/延性等）以及地震烈度（输入灾害强度），进而估计地震后的损伤程度、功能退化水平与恢复能力，并输出建筑整体或分层级的韧性评价结果（如韧性指标/等级/得分等）。

在本项目中程序：
* 非结构构件数量评估的EXCEL程序：美国联邦紧急事务管理局（FEMA）编写
* json文件解析程序：将字符串信息转换为json格式
* 韧性评价程序：依照国家韧性评价规范

项目需要解决的问题：
* 需要从EXCEL端导出“大规模构件清单/指标字符串”快速解析为结构化数据，满足同一建筑多工况或多建筑批处理的性能需求。

## 2 项目内容
该基于C++的json文件解析项目通过三个类实现：
* `Value`类可以承载任意 JSON 值（null / bool / number / string / array / object），并提供访问与类型转换接口。
* `Parser`类可以根据读取输入的 JSON 文本，按 JSON 语法解析，生成 json::Value。
* `Serializer`类可以把内存里的 json::Value（包括嵌套数组/对象）转换为 JSON 字符串；支持紧凑输出和 pretty-print（缩进/换行）

### 2.1 `Value`类的设计：
#### 2.1.1 设计目的：
* 统一表示 JSON 的所有数据类型：JSON 有 6 种基本类型（null/bool/number/string/array/object），Value用一个类型把它们全覆盖，作为库内的通用数据类型。
* 作为解析与序列化的中间表示（AST/DOM）：`Parser::parse()` 产出 `Value`；`Serializer::serialize()` 消费 `Value`。
* 提供便捷访问接口：调用方可以用类似脚本语言的方式访问对象键值、数组下标，并通过 asXxx() 获取强类型数据。
#### 2.1.2 实现方式：

* 通过枚举类的方式`enum class Type { Null, Boolean, Number, String, Array, Object }`保存当前值的“实际类型”。
内部按类型分别存放：`bool（布尔）double（数值，整型也会以数值形式处理）std::string* / Array* / Object*`（字符串/数组/对象用堆内存指针保存）

* RAII 管理资源：析构函数`~Value()`和内部`clear()`在类型切换/销毁时释放`new`出来的内存，避免泄漏。

* 拷贝/移动语义完善：
    * 拷贝构造/赋值：做深拷贝（字符串/数组/对象会复制内容）。
    * 移动构造/赋值：直接“接管指针”，并把源对象置为 Null，减少拷贝临时对象时的开销。

#### 2.1.3 特别之处：
既支持“值语义”，又尽量避免不必要拷贝：拷贝保证安全直观，移动保证性能。
* 数组/对象采用 STL 容器：
    * `Array = std::vector<Value>`（天然递归，可嵌套）
    * `Object = std::map<std::string, Value>`（键有序、实现简单）
* 访问体验友好（从示例可见）：
    * `value["user"]["name"].asString()`这种链式访问对应用层很方便。
实现上是“自研 variant”而非 std::variant：因为项目是 C++14，没法直接用 C++17 的 std::variant，所以用 type tag + 指针手工实现。

### 2.2 `Parser`类的设计
#### 2.2.1 设计目的：
* 把 JSON 文本解析为 Value 树结构：将字符串输入变成可以随机访问、类型安全（通过 asXxx）的内存对象。
* 提供明确的错误定位与报错：当输入不符合 JSON 语法时抛异常，阻止错误数据进入后续计算（比如你提到的“韧性评价”流程）。
#### 2.2.2 实现方式：
* 典型的递归下降解析（Recursive Descent Parser）：
维持两个核心状态：input_（整段文本）和 pos_（当前读到的位置）。
提供基础扫描函数：
    * `peek()`看当前字符
    * `next()`消费一个字符并前进
    * `skipWhitespace()`跳过空白
    * `match(expected)`判断并消费指定字符
* 按 JSON 文法拆分解析函数：`parseValue()`根据当前字符分派到不同分支：
    * `parserNull() / parseTrue() / parseFalse()`
    * `parseNumber()`
    * `parseString()`
    * `parseArray()`
    * `parseObject()`
* 异常处理策略：
解析遇到非法字符、缺失引号/冒号/逗号/括号不配对等情况时，调用`error(...)`抛出`JsonException`。
#### 2.2.3 特别之处：
* 解析结束有“完整性校验”：parse() 在拿到一个 Value 后还会检查是否还有多余字符（保证输入不含尾巴垃圾）。

* 实现透明、易调试/易改：递归下降的结构清晰，后续要扩展（比如支持注释、宽松 JSON、或更严格的数字格式）比较容易定位修改点。

* 面向 Value 的递归构建：数组/对象的解析会不断递归调用 parseValue()，天然支持任意层级嵌套。

### 2.3 `Serializer`类的设计
#### 2.3.1 设计目的：
* 把 Value 树转换为 JSON 文本：用于输出、存储、日志打印，或与其他语言（如 MATLAB/Python）交换数据。
* 同时支持“紧凑输出”和“美化输出”：
    * 紧凑：不含多余空格/换行，体积更小。
    * 美化：带缩进和换行，便于人工阅读与调试。
#### 2.3.2 实现方式：
* 按类型分派序列化：
    * `serializeValue(value, oss)`根据`value.type()`分发：
    * `null/bool/number/string/array/object`
* 细节功能拆分：
    * `serializeString()`处理字符串加引号与字符转义
    * `serializeArray()`递归序列化每个元素
    * `serializeObject()`输出 key-value，并递归序列化 value
* 格式化控制：
构造参数 pretty_ 和 indent_ 控制是否换行、缩进宽度。
通过 current_indent_ 跟踪当前层级，输出时插入相应空格。
#### 2.3.3 特别之处：
* 数值输出做了“整数外观”优化：当 double 的值等同于整型时，会按 `int 的形式输出（减少 1.00000 这类不美观情况）。
* 统一使用`std::ostringstream`流式拼接：避免频繁字符串拼接导致的多次分配，结构上也更清晰。
* 递归输出与 Value 结构一致：Value 怎么嵌套，序列化就怎么递归遍历，天然支持复杂 JSON。

## 3 这个项目用了`C++`的哪些新特性？
1) 移动语义（Move Semantics）+ noexcept
在 json::Value 中实现了：

* 移动构造：Value(Value&& other) noexcept
* 移动赋值：Value& operator=(Value&& other) noexcept
* 这属于现代 C++ 的关键能力（C++11 引入，C++14 中继续沿用），在你的库里意义很大：在返回大对象/容器搬运时避免深拷贝（字符串、数组、对象都可“搬指针”）。

2) 右值引用（T&&）
与移动语义配套出现的就是 T&&。Value(Value&&)、operator=(Value&&) 这些签名本身就是右值引用的使用。

3) enum class（强类型枚举）
Type 使用了：

强类型枚举能避免枚举值污染命名空间、避免隐式转 int，类型更安全（C++11 引入，C++14 兼容）。

4) nullptr / std::nullptr_t
Value 提供了：

用于表达 JSON 的 null，更现代、更安全（替代 NULL / 0 指针语义）。

5) 类型别名（using）
头文件里：

比 typedef 更清晰（C++11 引入）。

6) 范围 for（range-based for）
在 serializer.cpp 可看到类似：

用于遍历字符串/数组等（C++11 引入）。

7) auto（自动类型推导）
代码里如果有 auto（示例/实现中常见），属于现代 C++常用特性（C++11 引入）。即便你目前某些文件没有大量使用，写报告时也可以说明项目遵循 C++14 编译标准，允许使用 auto 简化迭代器等代码。

8) 统一初始化 / 列表初始化（{}）
在示例和一些对象构造中常见，比如构造 Object/Array、传参等使用 {} 初始化（C++11 引入）。

9) 标准库智能指针/内存头文件的“现代风格”（但你这里主要是手动 new/delete）
json.h 里包含了 <memory>，不过 Value 目前实际是手写资源管理（new std::string 等）。这点你可以在报告里写成：项目采用 RAII 思想实现析构与拷贝/移动控制，而不是依赖 GC。

## 4 递归下降算法体现在哪里？
递归下降算法体现在哪里？
主要体现在`json::Parser`里。

递归下降的典型特征是：每个语法规则对应一个解析函数，函数之间按文法结构互相调用；当遇到嵌套结构（array/object 里还有 value）时，就会递归调用同一个“解析 value”函数。

在你的实现中，对应关系大致是：

顶层入口：Parser::parse()
语法分派（相当于 <value> 规则）：Parser::parseValue()
具体规则函数：
parseString()（"..."）
parseNumber()（数字）
parserNull() / parseTrue() / parseFalse()（关键字）
parseArray()（[...]）
parseObject()（{...}）
“下降”体现：parseValue() 根据下一个字符选择分支
递归下降里的“下降”通常指：从高层规则 <value> 下降到更具体规则 <object>/<array>/<string>/...。

你这里就是 parseValue() 看 peek() 的字符：

`'{'` → 调 parseObject()
`'['` → 调 parseArray()
`'"'` → 调 parseString()
数字/- → 调 parseNumber()
n/t/f → 调 null/true/false 解析
这就是标准的“预测式分派”。

“递归”体现：parseArray() / parseObject() 里再次调用 parseValue()
递归点就在数组和对象内部，因为 JSON 的定义是：

array: [ value (, value)* ]
object: { string : value (, string : value)* }
所以当你解析 array/object 的元素时，元素本身又是一个 value（可能还是 array/object），于是必须回到 parseValue() —— 这就是递归。

典型结构是这样（用伪代码描述你文件里的逻辑）：

parseArray()（你项目里一定会类似这么写）
读入 [
如果不是 ]：
elements.push_back(parseValue()); ✅ 这里递归
while 还有 ,：
elements.push_back(parseValue()); ✅ 继续递归
读入 ]
parseObject() 同理
读入 {
解析 key（string）
匹配 :
obj[key] = parseValue(); ✅ value 位置递归
处理 , 分隔的更多键值对
读入 }