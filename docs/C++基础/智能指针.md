# 智能指针

## 什么是智能指针？
在C++中，有三种常用的智能指针：`std::unique_ptr`、`std::shared_ptr`、`std::weak_ptr`：
* `std::unique_ptr`是一种独占所有权的智能指针。它通过使用独占所有权的方式来管理资源，只能有一个`std::unique_ptr`指向同一个对象或数组。当`std::unique_ptr`超出作用域或被显式释放时，它会自动删除所管理的对象或数组。它通常用于表示独占的资源所有权，比如动态分配的单个对象或数组。
* `std::shared_ptr`是一种共享所有权的智能指针。它可以由多个`shared_ptr`指向同一个对象，通过引用计数来管理资源的生命周期。只有当最后一个`std::shared_ptr`超出作用域或被显式释放时，资源才会被删除。`std::shared_ptr`允许多个指针共享对同一资源的访问，通常用于表示共享的资源所有权。
* `std::weak_ptr`是一种弱引用的智能指针。它可以指向由`std::shared_ptr`管理的对象，但不会增加引用计数。`std::weak_ptr`主要用于解决`std::shared_ptr`的循环引用问题，通过`std::weak_ptr.lock()`方法可以获取一个有效的`std::shared_ptr`来访问被管理的对象。

## 为什么要使用`std::shared_ptr`？
在传统的C++编程中，使用`new`操作符分配的内存需要手动使用`delete`操作符释放，若忘记释放或者在异常情况下无法执行`delete`操作，就会造成内存泄漏。

`std::shared_ptr`可以自动处理内存的释放，当不再`std::shared_ptr`指向该对象时，对象的内存会被自动释放。

`std::shared_ptr`支持多个`std::shared_ptr`实例共享同一个对象的所有权。它通过引用计数机制来实现这一点，每个`std::shared_ptr`都会维护一个引用计数，记录有多少`std::shared_ptr`共享同一个对象。当引用计数变为0时，对象的内存会被释放。

## 为什么要使用`std::weak_ptr`？
`std::weak_ptr`主要用于辅助`std::shared_ptr`进行内存管理，解决`std::shared_ptr`可能存在的循环引用问题，同时还可以用于观察`std::shared_ptr`所管理对象的生命周期。

当两个或多个`std::shared_ptr`相互引用形成循环时，会导致引用计数永远不会降为0，从而造成内存泄漏。`std::weak_ptr`不会增加所指向对象的引用计数，因此可以打破这种循环引用。
```C++
#include <iostream>
#include <memory>

class B;

class A {
public:
    std::shared_ptr<B> b_ptr;
    ~A() { std::cout << "A destructor" << std::endl; }
};

class B {
public:
    std::weak_ptr<A> a_ptr;  // 使用 std::weak_ptr 打破循环引用
    ~B() { std::cout << "B destructor" << std::endl; }
};

int main() {
    std::shared_ptr<A> a = std::make_shared<A>();
    std::shared_ptr<B> b = std::make_shared<B>();
    a->b_ptr = b;
    b->a_ptr = a;
    return 0;
}
```

### 智能指针会造成内存泄漏吗？
