# 左值、右值和移动语义

## 左值和右值的区别？
左值指表达式结束后依然存在的持久对象，右值指表达式结束后就不再存在的临时对象。因此，左值持久，右值短暂。

## 左值引用和右值引用的区别？
* 左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个右值上。
* 右值引用必须绑定到右值的引用，通过`&&`获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。

## 如何将左值转换成右值？
`std::move`可以将一个左值强制转化为右值，继而可以通过右值引用使用改值：
```C++
#include <iostream> 
using namespace std; 

void fun1(int& tmp) { 
    cout << "fun1(int& tmp):" << tmp << endl; 
} 

void fun2(int&& tmp) { 
    cout << "fun2(int&& tmp)" << tmp << endl; 
} 

int main() { 
    int var = 11; 
    fun1(12); 
    // error: cannot bind non-const lvalue reference of type 'int&' to an rvalue of type 'int' 
    fun1(var); 
    fun2(1); 
}
```

## 右值引用

### 为什么要右值引用？

为了支持移动操作，新标准引入了一种新的引用类型——右值引用。

### 什么是右值引用？/右值引用的特殊之处

所谓右值引用就是必须绑定到右值的引用，通过`&&`来获取右值引用。

右值有一个重要的性质——**只能绑定到一个将要销毁的对象**。因此我们可以自由地将一个右值引用的资源“移动”到另一个对象中。

### 常见的左/右值引用

返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。可以将左值绑定到这类表达式的结果上。

返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。我们不能将一个左值引用绑定到这类表达式上，但可以将一个const的左值引用绑定到这类表达式上。

### `move`操作符

虽然不能将右值引用绑定到左值上，但是可以显式地将一个左值转换为对应的右值引用：

```C++
include<utility>

int &&rr3 = std::move(rr1); //rr1是一个左值
```

`move`告诉编译器，我们有一个左值，但我们希望像一个右值一样处理它。我们必须认识到，调用move就意味着承诺：处理对`rr1`赋值或者销毁它外，我们将不在使用它。在调用move后我们不能再对移动后的源对象的值做任何假设。

## 移动语义
移动语义通过右值引用和移动构造函数来优化对象在内存中的传递，避免不必要的数据复制。

因为传统的拷贝操作对于大型对象或资源密集对象来说可能会有很高的开销，因为它们需要将对象的所有数据复制到新的对象中。移动语义的引入解决了这一个问题，实现了对象资源的“移动”而非“复制”。

```C++
template <typename T>
typename remove_reference<T>::type&& move(T&& t)
{
    // T&&可以保留实参的左值右值的属性
	return static_cast<typename remove_reference<T>::type&&>(t);
}

string s1("hi!"), s2;
s2 = std::move(string("bye!")); // 正确
s2 = std::move(s1); // 正确
```

上述代码中`s2 = std::move(string("bye!"));`执行如下步骤：

* `string("bye!")`返回一个右值
* `T`被推断为`string`，`move`的函数参数类型为`string&&`
* `remove_reference<string>`的`type`成员是`string`
* move返回的类型为`string&&`

上述代码中`s2 = std::move(s1);`执行如下步骤：

* `s1`为一个左值
* `T`被推断为`string&`，`move`的函数参数类型为`string& &&`，最终折叠为`string&`
* `remove_reference<string&>`的`type`成员是`string`
* move返回的类型为`string&&`

上述步骤实现了`std::move`的基类。