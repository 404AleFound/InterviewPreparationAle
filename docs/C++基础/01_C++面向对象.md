# C++面向对象
## 1 什么是面向对象？
* 面向过程编程：一种以执行程序操作的过程或函数为中心编写软件的方法。程序的数据通常存储在变量中，与这些过程是分开的。所以必须将变量传递给它们的函数。缺点：随着程序变得越来越复杂，程序数据与运行代码的分离可能会导致问题。
* 面向对象编程：以创建和使用对象为中心，一个对象就是一个软件实体，它将数据和程序在一个单元中组合起来。对象的数据项，也称为其属性，存储在成员变量中。对象执行的过程也就是执行其成员函数的过程。将对象和过程绑定在一起则被称为封装。
* 面向对象编程：将数据成员和成员函数封装到一个类中，并声明数据成员和成员函数的访问级别（public、private、protected），以便控制用户对类对象对数据成员和成员函数的访问权限，起到一定的保护作用。而且在类的对象调用成员函数时，只需要知道成员函数的名、参数列表以及返回值类型即可，无需了解函数的实现原理。当类内部的数据成员或者成员函数发生变化时，只要其提供的外部接口没有发生改变，那就不会影响到外部的代码。
```c++
// 面向过程
#include <iostream>
using namespace std;

struct order {
    double price;
    int count;
    double discount;
}

double calcTotal(const Order& o) {
    return o.price * o.count * o.discount;
}

int main() {
    Order o{100.0, 3, 0.8};
    cout << calcTotal(o) << endl; // 240
}
```
```c++
// 面向对象
#include <iostream>
using namespace std;

class Order {
public:// 封装
    Order(double price, int count, double discount)
        : price_(price), count_(count), discount_(discount) {}

    double total() const {
        return price_ * count_ * discount_;
    }

    void setDiscount(double discount) {
        discount_ = discount;
    }

private:
    double price_;
    int count_;
    double discount_;
};

int main() {
    Order o(100.0, 3, 0.8);
    cout << o.total() << endl; // 240
}
```

## 2 C++面向对象的三大特性？
面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含成员变量和成员方法：
* 封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，这样外层调用类只会调用到设计者想让他调用的方法；
* 继承：设计一个基类，然后分别设置子类去继承基类的一些方法，尤其是虚函数，针对不同子类的特点对虚函数进行重写；继承分为公有继承和私有继承，公有继承可以将基类的成员原封不动的继承下来，子类的权限和基类相同，私有继承则会改变子类对于基类成员的权限，将其改为私有，不对用户开放。
* 多态：通过函数重载和虚函数实现的，函数重载可以使得相同的函数面对不同的参数个数或者类型进行不同的方式实现。

## 3 封装
### 3.1 什么是封装？
封装（Encapsulation）是面向对象编程中的核心特性之一，指的是**将数据（成员变量）和操作数据的代码（成员函数）绑定在一起，隐藏对象的内部实现细节，只对外暴露有限的接口**。

通过访问权限修饰符可以控制用户对类内成员的访问权限。

### 3.2 如何实现封装？
C++中通过类的方式实现类封装。

### 3.3 为什么要使用封装？
* 通过封装可以增强编程安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，特定的访问权限来使用类的成员；因此封装可以隐藏实现细节，使得代码模块化。

## 4 多态
### 4.1 什么是多态？

### 4.2 如何实现多态？
多态分为编译时多态（静态多态）和运行时多态（动态多态）：
* **编译时多态**，也称为静态多态或早绑定，主要通过函数重载和模板实例化实现的。不同的模板参数实例化导致调用不同的函数，这就是所谓的编译器多态。相比较于运行期多态，实现编译期多态的类之间并不需要成为一个继承体系，它们之间可以没有什么关系，但约束是它们都有相同的隐式接口，在编译期间，编译器推断出模板参数，因此确定调用的是哪个具体类型的接口，不同的推断结果调用不同的函数。

* **运行时多态**，也称为动态多态或晚绑定，主要通过依赖于虚函数和继承实现的。当基类的指针或引用指向派生对象时，调用的虚函数将是拍摄类的版本，这就是实现了运行时多态。

#### 4.2.1 编译时多态
编译时多态主要通过函数重载和模板实例化实现的。


#### 4.2.2 运行时多态
运行时多态，也称为动态多态或晚绑定，主要通过依赖于虚函数和继承实现的。

每个包含**虚函数**的类（或有虚函数的类的派生类）都有一个虚函数表。虚函数表是一个函数指针数组，其中存放着该类所有虚函数的地址。每个对象中都有一个隐藏的指针`vptr`指向该类的虚函数表。当通过基类指针或引用调用虚函数时，编译器会生成代码来通过对象的`vptr`找到虚函数表，并在表中查找相应函数的地址，然后调用该函数。

虚函数是通过在基类中声明一个函数为`virtual`来实现的。这标志着这个函数可以被派生类重写（override）。当通过基类指针或引用调用虚函数时，C++会查找实际对象的类型，调用对应的子类实现，而不是基类的实现。

运行时多态的条件：
* 基类中声明虚函数，使用`virtual`关键字。
* 派生类中覆盖（重写）基类的虚函数。
* 通过基类的指针或引用来调用虚函数。

#### 4.2.3 继承中的类型转换
C++中的基类和派生类的类型转换来自于继承机制，一个派生类对象包含多个组成部分：
* 属于派生类对象自己的部分
* 属于继承的基类的部分。若有多个基类，则对应的基类部分也有多个。

正是基于派生类对象中包含有与其基类对应的组成部分，我们能把派生类的对象当成基类对象使用，即可以将基类的指针或引用绑定到派生类对象中的基类部分上。

由于派生类和基类存在类型转换，且该转换是在运行时确定的，故引入**静态类型和动态类型**概念。

* 动态类型是表达式指向内存中对象的类型，表达式的静态类型是其在声明时的类型。
* 当表达式既不是引用也不是指针时，其静态类型和动态类型是一致的。


```C++
Derived d;
Base* pb = &d; // 静态类型：Base*，动态类型：指向 Derived 对象
pb->who(); // 输出：I am Derived （多态体现）

Base& rb = d; // 静态类型：Base&，动态类型：Derived
rb.who(); // 输出：I am Derived

Base b2 = d; // 静态类型和动态类型均为 Base （对象切片发生）
b2.who(); // 输出：I am Base
```

注意，不能将一个派生类指针绑定在基类指针：
```C++
class Base {
public:
    void foo() {}
};

class Derived : public Base {
public:
    void bar() {}
};

Derived d;
Base* pb = &d;   
// 正确，基类指针指向派生类对象的基类部分
Base b;
// Derived* pd = &b;
// 错误，基类对象不能赋给派生类指针（不能隐式转换）
```
派生类对象和基类对象之间不存在类型转换：
* 派生类向基类的自动转换只对指针或应用类型有效。
* 当使用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被切掉（sliced down）
```C++
class Base {
public:
    int baseData = 1;
    virtual void print() 
    { std::cout << "Base: " << baseData << std::endl; }
};

class Derived : public Base {
public:
    int derivedData = 100;
    void print() override 
    { std::cout << "Derived: " << baseData << ", " << derivedData << std::endl; }
};

Derived d; 
d.baseData = 2; 
d.derivedData = 200;

Base b = d;  // 对象切片：只拷贝 Base 部分，Derived 部分被“切掉”
b.print();   // 输出 Base: 2 —— 派生类信息丢失

Base& br = d;  // 引用或指针无切片
br.print();    // 输出 Derived: 2, 200 （多态）

Base* bp = &d;
bp->print();   // 输出 Derived: 2, 200 （多态）

```
### 4.3 虚函数表？
* 先将基类中的虚表内容拷贝一份到派生类虚表中。
* 如果派生类重写了基类中某个虚函数，用派生类自己的虚函数替换虚表中基类的虚函数。
* 派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。

### 4.4 为什么要使用多态？
使用多态的目的，是让调用方只依赖“抽象接口”，而不是依赖具体类型，从而获得更好的扩展性与可维护性。

* **降低耦合（面向接口编程）**：调用者只关心基类/接口提供的行为，不需要写大量 `if/else` 或 `switch` 去判断具体类型。
* **增强可扩展性（开闭原则）**：新增一种派生类，只要实现/重写基类接口，原有调用代码通常无需修改（对扩展开放，对修改关闭）。
* **统一处理多种对象（替换能力）**：在同一个容器中以 `Base*`/`Base&` 存放不同派生类对象，并对它们执行同一组操作（如 `draw()`、`encode()`、`process()`），实际执行由对象的动态类型决定。
* **便于维护与测试**：可以用 Mock 派生类替换真实实现进行单元测试（例如 `FakeEncoder`、`MockSocket`），隔离外部依赖。
* **让架构更清晰**：把稳定的协议/接口上移到抽象层，把易变的实现细节下沉到具体类中，模块边界更明确。


## 5 继承
### 5.1 什么是继承？

### 5.2 如何实现继承？

### 5.3 继承与控制访问？
不同派生类继承的方式对用户的权限如下：

| 继承方式    | 基类 `public` 成员 | 基类 `protected` 成员 | 基类 `private` 成员 |
| ----------- | ------------------ | --------------------- | ------------------- |
| `public`    | `public`           | `protected`           | 不可访问            |
| `protected` | `protected`        | `protected`           | 不可访问            |
| `private`   | `private`          | `private`             | 不可访问            |
### 5.4 为什么要使用继承？

## 6 补充
### 6.1 重载、重写、隐藏的区别是什么？

|概念|解释|
|---|---|
|重载|同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。|
|重写|指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有`virtual`修饰。|
|隐藏|指派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。|

```C++
// 重载样例
class A {
public:
    void fun(int tmp);
    void fun(float tmp);            // 重载 参数类型不同（相对于上一个函数）
    void fun(int tmp, float tmp1);  // 重载 参数个数不同（相对于上一个函数）
    void fun(float tmp, int tmp1);  // 重载 参数顺序不同（相对于上一个函数）
    int fun(int tmp);               // error: 'int A::fun(int)' cannot be overloaded 错误：注意重载不关心函数返回类型
};
```

```C++
// 隐藏样例
#include <iostream>
using namespace std;

class Base {
public:
    void fun(int tmp, float tmp1) {
        cout << "Base::fun(int tmp, float tmp1)" << endl;
    }
};

class Derive : public Base {
public:
    void fun(int tmp) {
        cout << "Derive::fun(int tmp)" << endl;
    } // 隐藏基类中的同名函数
};

int main() {
    Derive ex;
    ex.fun(1);       // Derive::fun(int tmp)
    ex.fun(1, 0.01); // error: candidate expects 1 argument, 2 provided
    return 0;
}
```

```C++
// 重写样例
#include <iostream>
using namespace std;

class Base {
public:
    virtual void fun(int tmp) {
        cout << "Base::fun(int tmp) : " << tmp << endl;
    }
};

class Derived : public Base {
public:
    virtual void fun(int tmp) {
        cout << "Derived::fun(int tmp) : " << tmp << endl;
    } // 重写基类中的 fun 函数
};

int main() {
    Base *p = new Derived();
    p->fun(3); // Derived::fun(int) : 3
    return 0;
}
```