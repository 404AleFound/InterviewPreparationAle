# C++的三五零法则

## 三法则

### 三法则是什么？

在C++编程中，如果一个类定义了下面三个成员函数之一，那么另外两个成员函数需要程序员手动定义：

* 析构函数
* 拷贝构造函数
* 拷贝赋值运算符

### 为什么是这样的？

* 首先，只要我们定义了这三个成员函数中的一个，剩下两个将由编译器自动生成，而编译器生成的版本将会和程序员自定义的版本产生冲突。
* 同时，当一个类需要手动定义析构函数，几乎总是出于同一个目的：该类正在手动管理某种资源，最典型的就是裸指针指向的推内存。

```C++
class MyString {

}
```



## 五法则

### 五法则是什么？

在C++引入移动语义（Move Semantics）后，使得三法则在现代C++中变为了五法则，五法则在三法则的基础上增加了移动构造函数和移动赋值运算符。

移动可以减少一些情况下的拷贝开支，提升了性能。

### 为什么是这样？

因为在合成的成员函数中，如果没有提供移动构造函数和移动赋值运算符，编译器不会为类自动合成移动的版本。在这种情况下，所有的右值实参都会去匹配`const`引用，从而导致移动操作退化为拷贝。

## 零法则

### 零法则是什么？

**零法则**是如果一个类负责业务逻辑，那么它就不应该同时负责手动的资源管理：

* 将所有需要手动管理的资源都封装在专门的资源管理类中
* 业务逻辑类只需要将这些资源管理类作为自己的成员变量即可

### 为什么是这样？

资源管理类内部会严格遵循五法则，确保资源的拷贝、移动和释放都是正确的。而最重要的资源管理类，就是标准库为我们提供好的：

* `std::string`：管理动态字符串
* `std::vector`：管理动态数组
* `std::unique_ptr/std::shared_ptr`：管理单个活共享的堆资源