# 完美转发
## 1 什么是完美转发？
用于将函数模板中的参数**精确地传递**给另一个函数，无论参数是左值还是右值，类型修饰符（const、volatile等）都能被完整保留。

## 2 如何使用完美转发？
利用**模板类型参数推导**，结合 **右值引用** 和**`std::forward`** ，实现完美转发。
```C++
#include <iostream>
#include <utility>

void foo(int& x) {
    std::cout << "foo(int&): " << x << std::endl;
}

void foo(int&& x) {
    std::cout << "foo(int&&): " << x << std::endl;
}

template<typename T>
void perfectForward(T&& param) {
    // 完美转发
    foo(std::forward<T>(param));
}

int main() {
    int a = 10;
    perfectForward(a);      // 传递左值
    perfectForward(20);     // 传递右值
}
```
注意：
* `T&&` 在模板中是所谓的**转发引用**（又叫通用引用）。
* `std::forward<T>(param)` 会根据 `T` 推断的类型决定转发为左值引用还是右值引用。
### 2.1 `std::forward`机理：万能引用
`std::forward` 是C++11引入的一个**完美转发辅助函数**，主要用于转发函数模板中的参数，**保持参数的值类别（左值或右值）不变**。


```C++
template<typename T>
void func(T&& param);
// 在这里虽然param是一个万能引用，可以绑定左值和右值
// 但是在`func`内部直接传给其他函数时，如果直接传`param`，编译器会将其与左值的版本匹配
// 无法和右值的重载函数匹配
```

`std::forward`的实现核心如下：

```C++
template<typename T>
T&& forward(std::remove_reference_t<T>& param) {
	return static_cast<T&&>(param);
}

// 传入int左值a，T被推断为左值的引用int&，函数返回int& &&，经过折叠变为int&
// 传入右值0，T被推断为
```

关键点介绍如下：

* `T&&`返回一个万能引用，而不是一个值，如果返回param对象，则相当于返回一个右值，那么这个函数就毫无意义了，所以需要`static_cast`类型转换为引用。
* 传入右值时T被推断为`int`，传入左值时T被推断为`int&`


## 3 为什么要使用完美转发？
某些函数需要将其一个或多个实参连同类型不变地转发给其他函数，不想失去函数参数的“左值/右值”和“`const`/`const`”信息。

* 直接传参有可能造成不必要的拷贝或移动。
* 如果只是使用普通引用或值传递，可能会破坏参数的原始类型和引用类别。
* 完美转发允许我们写出高效且类型安全的转发代码。