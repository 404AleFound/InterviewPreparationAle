# 栈与队列

## 栈原理及底层实现
- 概念：栈（Stack）是后进先出（LIFO）的线性结构。常用操作：push（入栈）、pop（出栈）、peek/top（查看栈顶）。
- 典型应用：函数调用栈、表达式求值（中缀转后缀）、括号匹配、深度优先搜索（DFS）、撤销/重做功能等。
- 底层实现
    - 数组（动态数组）实现
        - 使用数组和一个索引表示栈顶，push 在末尾追加，pop 减少索引。
        - 时间复杂度：push/pop O(1)（动态数组常见为摊还 O(1)）。
        - 优点：内存连续、访问局部性好；缺点：需要扩容策略。
    - 单向链表实现
        - 在链表头部插入/删除作为栈顶，push/pop 均为 O(1)。
        - 优点：不需整体移动或扩容；缺点：额外的指针开销。
- 常见注意点：栈溢出（递归过深）、并发时需要锁或无锁结构。

示例（C++ 风格）：
```cpp
#include <vector>
#include <stdexcept>

class ArrayStack {
public:
    ArrayStack() = default;
    void push(int x) { data.push_back(x); }
    int pop() {
        if (data.empty()) throw std::out_of_range("pop from empty stack");
        int v = data.back();
        data.pop_back();
        return v;
    }
    int top() const {
        if (data.empty()) throw std::out_of_range("top of empty stack");
        return data.back();
    }
    bool empty() const { return data.empty(); }
private:
    std::vector<int> data;
};
```

## 队列原理及底层实现
- 概念：队列（Queue）是先进先出（FIFO）的线性结构。常用操作：enqueue（入队）、dequeue（出队）、peek/front（查看队首）。
- 典型应用：任务调度、广度优先搜索（BFS）、消息队列、流量整形等。
- 底层实现
    - 循环数组（环形缓冲区）
        - 使用固定或可扩容数组，维护 head 和 tail 索引，元素位置使用 modulo 运算。
        - enqueue/dequeue 均为 O(1)。
    - 链表（带尾指针）
        - 在尾部插入，在头部删除，enqueue/dequeue 均为 O(1)。
    - 双端队列（deque）
        - 支持在两端插入和删除，适合需要两端操作的场景。
- 常见注意点：边界条件（满/空判断）、缓冲区扩容策略、并发安全（阻塞队列、无锁队列）。

示例（C++ 标准库）：
```cpp
#include <deque>

std::deque<int> q;
q.push_back(1);    // enqueue
int front = q.front();
q.pop_front();     // dequeue
```

## 逆波兰表达式求值
- 思路：遍历后缀表达式的每个 token，遇到数字压栈，遇到运算符弹出所需操作数、计算结果后将结果压回栈，遍历结束时栈顶即为结果。
- 支持的运算、负数与多位数需注意 token 划分。
- 时间复杂度 O(n)，空间复杂度 O(n)。

示例（C++）：
```cpp
#include <string>
#include <vector>
#include <stack>

int evalRPN(const std::vector<std::string>& tokens) {
    std::stack<int> st;
    for (const auto& t : tokens) {
        if (t == "+" || t == "-" || t == "*" || t == "/") {
            int b = st.top(); st.pop();
            int a = st.top(); st.pop();
            if (t == "+") st.push(a + b);
            else if (t == "-") st.push(a - b);
            else if (t == "*") st.push(a * b);
            else if (t == "/") st.push(a / b); // C++ 整数除法向零截断
        } else {
            st.push(std::stoi(t));
        }
    }
    return st.top();
}
// 示例: {"2","1","+","3","*"} -> (2+1)*3 = 9
```

## 优先级队列

- 概念：优先级队列（Priority Queue）每次取出“优先级最高”的元素（根据比较规则，可理解为最大值或最小值）。  
- 常用实现：二叉堆（binary heap），用数组表示的完全二叉树，支持插入、取顶、弹出顶元素都在对数/常数时间内完成。

### `std::priority_queue` 三个模板参数含义

标准库声明原型（简化）：

```cpp
template <
    class T,                          // 1. 元素类型
    class Container = std::vector<T>, // 2. 底层容器类型
    class Compare = std::less<typename Container::value_type> // 3. 比较器
> class priority_queue;
```

1. **`T`：元素类型**
   - 队列里存放的元素类型，如 `int`、`long long`、`std::pair<int,int>`、自定义结构体等。
   - 示例：`std::priority_queue<int>` 中的 `T` 是 `int`。

2. **`Container`：底层容器类型（默认 `std::vector<T>`）**
   - 实际存储元素的顺序容器，必须支持：
     - 随机访问：`operator[]`
     - 在末尾插入/删除：`push_back` / `pop_back`
     - 获取元素个数：`size`
   - 一般保持默认 `std::vector<T>` 即可，极少需要修改。
   - 示例：`std::priority_queue<int, std::vector<int>>`

3. **`Compare`：比较器（决定“优先级高低”的规则）**
   - 必须是“**严格弱序关系**”的可调用对象，比如函数对象、`std::less<T>`、`std::greater<T>` 或自定义仿函数 / lambda。
   - 对于 `std::priority_queue`：
     - 默认 `Compare = std::less<T>`：**大顶堆**（top 为“最大值”）。
     - 如果使用 `std::greater<T>`：**小顶堆**（top 为“最小值”）。
   - 注意：`Compare(a, b)` 为 `true` 时，表示 “`a` 的优先级比 `b` 低”，因此堆顶是“最不小的”元素（不必细究实现细节，只需记：`less` => 最大堆，`greater` => 最小堆）。

### 常见用法示例

#### 1. 默认：最大堆（大顶堆）

```cpp
#include <queue>
#include <vector>

std::priority_queue<int> max_heap;  // 等价于 std::priority_queue<int, std::vector<int>, std::less<int>>

max_heap.push(5);
max_heap.push(1);
max_heap.push(3);
int max_val = max_heap.top();  // 5
max_heap.pop();
```

- `T = int`
- `Container = std::vector<int>`
- `Compare = std::less<int>`（最大值优先）

#### 2. 最小堆（小顶堆）

```cpp
#include <queue>
#include <vector>
#include <functional>  // std::greater

std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;

min_heap.push(5);
min_heap.push(1);
min_heap.push(3);
int min_val = min_heap.top();  // 1
min_heap.pop();
```

- `T = int`
- `Container = std::vector<int>`
- `Compare = std::greater<int>`（最小值优先）

#### 3. 存 `pair`，按第二个元素升序（最小堆）

```cpp
#include <queue>
#include <vector>
#include <functional>

using PII = std::pair<int, int>;
struct CmpBySecond {
    bool operator()(const PII& a, const PII& b) const {
        return a.second > b.second;  // second 小的优先级高
    }
};

std::priority_queue<PII, std::vector<PII>, CmpBySecond> pq;
```

- `T = std::pair<int,int>`
- `Container = std::vector<PII>`
- `Compare = CmpBySecond`，通过自定义比较器实现复杂优先级规则。

### 复杂度与应用

- 二叉堆性质：
  - `push` / `pop`：`O(log n)`
  - `top`：`O(1)`
- 常见应用：
  - Dijkstra 最短路、A* 搜索
  - K 路归并、Top K 问题
  - 任务调度、事件模拟等
- 更高级实现：斐波那契堆、配对堆、基于平衡搜索树的优先队列，主要用于理论分析或特殊场景。

```

小结：栈和队列是基础抽象，选择数组或链表、循环缓冲或堆取决于使用场景与性能要求；逆波兰使用栈直接求值，优先级队列常用堆实现以保证对数时间的插入与删除。
