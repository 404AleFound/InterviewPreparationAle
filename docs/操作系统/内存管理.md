# 内存管理
* 内存的分配与回收：
    * 当作业或进程创建后系统会为他们分配内存空间，当结束后内存空间也会被回收。
    * 分为连续分配和非连续分配，连续分配根据分配方式不同分为单一连续分配、固定分区分配和动态分区分配（动态分配算法有：首次适应、最佳适应、最坏适应和临近适应算法）；非连续分配分为基本分页存储管理、基本分段存储管理和段页式存储管理。

* 地址的转换：
    * 将程序中的逻辑地址转换成内存中的物理地址
    * 使用MMU将逻辑地址转换为物理地址。

* 内存的扩充：
    * 利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存
    * 基于局部性原理使用了虚拟内存来对物理内存进行扩充。

* 内存的保护：
    * 保证个个作业在自己的内存空间内运行，互不干扰
    * 为了保护操作系统各个进程直接互不干涉，从而提出了内存保护。内存保护是在cpu中设定了重定位寄存器和界地址寄存器，当进程访问内存的时候就会判断其是否越界。

## 1 为什么要有虚拟内存？
## 1.1 虚拟内存
## 1.2 内存分段
### 为什么提出内存分段机制？
* 在早期的操作系统中（或者没有虚拟内存的时代），程序直接访问物理内存是极其危险且低效的。为了解决这个问题，人们引入了内存分段。

### 核心思想？ 
* 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。

### 虚拟内存和物理内存的映射？
* 分段机制下的虚拟内存地址由两部分构成：段选择因子和段内偏移量。段选择因子中包含段号和特权等标志位，段号用于段表的索引，根据段表的索引可以从段表中查找出这个段的基地址、段的界限和特权等级等。段内偏移量，应当位于0和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量，得到物理内存地址。
* 因此，内存分段机制是通过段表将虚拟地址与物理地址进行转换的，分段机制会根据程序的逻辑归属，将程序的虚拟地址分为四个段，每一个段在段表中都有一个项，在这一项找到段的基地址，再加上偏移量，于是就可以找到其对应的实际物理内存中的地址。

### 内存分配中的内存碎片？
* 内存碎片分为内部碎片和外部碎片。
* 内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；内部碎片是处于（操作系统分配的用于装载某一进程的内存）区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存储块。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。
* 外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。

### 内存分段的不足以及解决措施？
* 内存碎片问题。内存分段管理可以根据有多少内存就分配多大的段，因此不会出现内部内存碎片。但是由于每一个段的长度不固定，所以多个段未必能恰好使用所有的内存空间，因此产生了多个不连续的小物理内存，导致新的程序无法背装载，也就是出现了外部内存碎片问题。
* 内存交换的效率较低。为了解决外部内存碎片的问题，采用了内存交换的方式进行解决。这意味着需要将内存中现有的某些段先写入磁盘（换出），腾出空间后再重新排序或读回（换入）。由于磁盘的访问速度比内存慢几个数量级（磁盘是毫秒级，内存是纳秒级），而一个段通常很大（几 MB 甚至几十 MB），频繁地在磁盘与内存之间拷贝大量数据会导致系统性能急剧下降，造成严重的停顿。


## 1.3 内存分页
### 为什么提出内存分页机制？
* 为了解决外部内存碎片问题和内存交换效率过低的现象，提出了内存分页机制。
* 解决外部内存碎片问题：内存分页中，由于内存空间都是预先划分好的，也就不会像内存分段一样，在段与段之间产生间隙非常小的内存，这正是分段会产生外部内存碎片的原因。而采用了分页，页与页之间是紧密排列的，所以不会有外部碎片。但是，因为内存分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费，所以针对内存分页机制会有内部内存碎片的现象。
* 解决内存交换效率低：如果内存空间不够，操作系统会把其他正在运行的进程中的最近没被使用的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个或者几个页，不会花太多时间，内存交换的效率就相对比较高。页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。

### 核心思想？
* 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在+Linux+下，每一页的大小为+4KB。

### 虚拟内存和物理内存的映射？
* 地址结构包含两部分，第一部分是页号，根据页号的位数可以算出地址结构可容纳最大页数；第二部分是页内偏移量(W)，可以计算出页面的大小。地址结构决定了虚拟内存的寻址空间有多大。
* 将虚拟地址分隔为页号和偏移量；根据页号，从页表里查询对应的物理页号；根据物理页号，再根据之前的偏移量就得到了物理内存地址。

### 简单分页的不足以及解决措施？
* 空间上的缺陷（页表太大）：因为操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大。在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB ($2^{12}$)，那么就需要大约 100 万 ($2^{20}$) 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有4MB的内存来存储页表。这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。那么，如果有 100 个进程的话，就需要400MB的内存来存储页表，这是非常大的内存了，更别说64位的环境了。
* 解决措施：采用多级页表（Multi-level Page Table）的方式来解决。多级页表就是将原本一张大的页表，拆分成若干小的页表，一级页表指向二级页表，二级页表再指向实际的页框。这样一来，就算是进程数量非常多，活跃的进程也不可能有那么多，所以只需要为活跃的进程维护页表，非活跃的进程可以直接释放掉对应的页表，页表占用的内存自然也就少了。另外，Linux 还采用了页表项懒惰清除（Lazy Clearing Page Table Entry）和反向映射（Reverse Mapping）等技术来进一步优化内存分页的性能开销。

## 1.4 段页式内存管理
内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常被分为段页式内存管理。为每个作业或者进程建立一张段表以管理内存分配与释放、缺段处理等。另外由于一个段又被划分为若干个页，每个段必须建立一张页表以把段中的虚页变换为内存中的实际页面。段页式管理是段式管理和页式管理相结合而成，具有两者的优点；另外由于管理软件的增加，复杂性和开销也增加。另外需要的硬件以及占用的内存也有所增加，使得执行速度下降。

### 段页式内存管理的实现方式

## 1.5 Linux内存分布
