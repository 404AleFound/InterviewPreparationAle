# 进程管理
## 1 进程、线程、协程
### 1.1 进程、线程、协程概念
* 进程概念。进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。
* 线程概念。线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。
* 协程概念。协程是一种比线程更加轻量级的存在。协程完全由程序所控制（在用户态执行），带来的好处是性能大幅度的提升 一个操作系统中可以有多个进程；一个进程可以有多个线程；同理，一个线程可以有多个协程。由于协程切换是在线程内完成的，涉及到的资源比较少，几乎只是切换了寄存器和协程栈的内容。
操作系统开一个进程要分配哪些资源：
每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段。

### 1.2 进程和线程的区别
* 进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）
* 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。 线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
* 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式(IPC)进行。
* 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

### 1.3 协程的作用
IO型的操作，利用协程在IO等待时间就去切换执行其他任务，当IO操作结束后再自动回调，那么就会大大节省资源并提供性能，从而实现异步编程（不等待任务结束就可以去执行其他代码）。

### 1.4 协程和线程的区别
* 由于协程的特性, 适合执行大量的I/O 密集型任务, 而线程在这方面弱于协程。协程涉及到函数的切换, 多程涉及到线程的切换, 所以都有执行上下文, 但是协程不是被操作系统内核所管理, 而完全是由程序所控制（也是在用户态执行）, 这样带来的好处就是性能得到了很大的提升, 不会像线程那样需要在内核态进行上下文切换消耗资源，因此协程的开销远远小于线程的开销。
* 同一时间, 在多核处理器的环境下, 多个线程是可以并行的，但是运行的协程的函数却只能有一个，其他的协程的函数都被暂停, 即协程是并发的。
* 由于协程在同一个线程中, 所以不需要用来守卫临界区段的同步性原语（primitive）比如互斥锁、信号量等，并且不需要来自操作系统的支持。在协程之间的切换不需要涉及任何系统调用或任何阻塞调用
* 通常的线程是抢先式(即由操作系统分配执行权), 而协程是由程序分配执行权


线程的六种状态：新创建、可运行、被阻塞、等待、计时等待、被终止。
进程的五种状态：创建状态、运行状态、就绪状态、阻塞状态、退出状态。
进程的解释如下：
（1）三种基本状态，分别是：运行态，这个时候进程占用cpu资源，并在cpu上运行，一个事件同时最多运行的cpu数量由机器cpu核心数决定。如果cpu已经被占满了，并且程序所需的所有资源都已经就绪了，例如网络接收缓冲区满了，这个时候进程就进入了就绪态，只需要cpu就可以立马运行。如果进程需要的资源被占用，那么进程就需要等待，这个状态就是进程的阻塞态。
（2）还有两个状态是，进程或者线程创建的时候，操作系统需要为进程或者线程分配所需的内存空间，初始化进程PCB或者线程的TCB等，这个时候进程处于创建态。当程序运行结束的时候，或者因为bug导致进程无法执行下去，操作系统需要回收分配的内存资源、撤销分配的PCB以及TCB，这个状态是进程的终止态。
（3）如果进程/线程不断的创建，系统资源已经不能满足进程运行的需求，这个时候就必须把某些进程挂起到磁盘镜像中，不参与进程的调度，起到平滑系统操作负荷的目的，这个时候就对应了进程或者线程的挂起等待态、挂起就绪态。常见的需要将进程或者线程挂载到磁盘的情况：
	a、系统中的进程或者线程均处于等待或者阻塞状态，处理器空闲。
	b、进程或者线程太多、系统资源不足的时候。
	c、换出定期执行的任务，减轻系统负担。

进程的空间布局：程序段、初始化过的数据、未初始化过的数据、栈、堆。

## 2 如何选择多线程或多进程
* 频繁修改：需要频繁创建和销毁的优先使用多线程。因为进程的创建和销毁开销很大（分配/回收内存、页表等），而线程只是一个轻量级的执行单元。
* 计算量：需要大量计算的优先使用多线程，因为需要消耗大量的CPU资源且切换频繁，所以多线程好一些。
* 相关性：任务间相关性比较强的用多线程，比较弱的用多进程，因为多线程之间资源共享和通信更加方便。
* 多分布：需要拓展到多机分布的用多进程，需要拓展到多核分布的用多线程。
* 稳定性：若需要高稳定性，首选多进程。因为一个子进程崩溃通常不会影响主进程或其他子进程（内存隔离）；而一个线程崩溃（如段错误）往往会导致整个进程挂掉。
* 并发性：在单核CPU下，多进程和多线程效果差不多（甚至多线程开销更小）；但在多核多CPU架构下，多线程可以更高效地利用共享缓存（L2/L3 Cache），提高并发效率。

## 3 进程调度算法
### 3.1 先来先服务调度算法
* 先进就绪队列，则先被调度，先来先服务是最简单的调度算法。当前面任务耗费很长时间执行，那么后面的任务即使只需要执行很短的时间，也必须一直等待，属于非抢占式。
### 3.2 最短作业优先调度算法
* 执行时间短的任务先进行调度，该调度算法对长作业不利，容易造成长作业任务饥饿。
### 高响应比优先调度算法
* 也被称为高性价比优先。该算法综合考虑了**等待时间**和**服务时间（执行时间）**，每次选择**响应比（Response Ratio）最高**的进程进行调度。
* **响应比计算公式**：`响应比 = (等待时间 + 要求服务时间) / 要求服务时间 = 1 + (等待时间 / 要求服务时间)`
* **特点**：
    * 如果作业的等待时间相同，则服务时间越短，响应比越高，有利于短作业（类似短作业优先）。
    * 如果作业的服务时间相同，则等待时间越长，响应比越高，有利于先来的作业（类似先来先服务）。
    * 对于长作业，随着等待时间的增加，其响应比也会逐渐升高，最终能够得到执行，从而**避免了“饥饿”现象**。
### 3.3 最高优先级调度算法
* 根据任务的优先级进行任务的调度，如果多个进程优先级相同，则按照先来先服务的方式依次执行。优先级调度可以进一步细分为抢占式和非抢占式。
    * 非抢占式：表示一旦该进程占有CPU就将一直执行到拮束或者阻塞。
    * 抢占式：进程执行期间，一旦有更高优先级的进程进入就绪队列，那么该进程就会被暂停，重回就绪队列，让更高优先级的进程执行。但是为了防止最高优先级进程一直执行，每个进程依然有自己的时间片，每次时间片结束后，会根据一定规则降低该进程优先级，避免某些最高优先级长作业进程一直占用CPU。 但是优先级调度可能会导致低优先级的进程永远不会执行。
### 3.4 时间片轮转调度算法
* 每一个进程会被分配一个时间片，表示允许该进程在这个时间段运行，如果时间结束了，进程还没运行完毕，那么会通过抢占式调度，将CPU分配给其他进程，该进程回到就绪队列。这是一种最简单最公平的调度算法，但是由于进程的切换，需要耗费时间，如果时间片太短，频繁进行切换，会影响效率。如果进程时间片太长，有可能导致排后面的进程等待太长时间。
### 3.5 多级反馈队列调度算法
* 多级反馈队列调度基于时间片轮转和优先级调度，设置多个就绪队列，赋予每个就绪队列优先级，优先级越高的队列进程的时间片越短。当有新的进程创建时，先进入第1级就绪队列，时间片结束之前就运行完毕，则终止，否则进入第2级队列等待下一次调度，只有高优先级执行完毕之后才会执行低优先级任务队列。同一优先级的任务队列按时间片轮转执行。为了避免进程饥饿问题，每经过一段时间就会将系统中所有工作重新加入最高优先级队列。

## 4 进程上下文切换、线程上下文切换、中断上下文切换？
* 进程上下文切换
    * 进程是由内核来管理和调度的，进程的切换只能发生在内核态，因此进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。
    * 进程上下文切换过程：
        1. 保存处理机上下文，包括程序计数器和其他寄存器。
        2. 更新PCB信息。
        3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
        4. 选择另一个进程执行，并更新其PCB。
        5. 更新内存管理的数据结构。
        6. 恢复处理机上下文。
* 线程上下文切换
    * 线程与进程最大的区别在于，线程是操作系统调度的最小单位，而进程是操作系统分配资源的最小单位。
    * 如果前后两个线程属于不同进程。此时因为资源不共享，所以切换过程就跟进程上下文切换是一样的。前后两个线程属于同一个进程。此时虚拟内存是共享的，上下文切换时，虚拟内存这些资源保持不动，只需要切换线程的私有数、寄存器等不共享的数据。
* 进程切换和线程切换的区别  
    * 因为每一个进程都有自己的虚拟地址空间，进程内的线程共享进程的虚拟地址空间。
    * 当进行进程切换的时候需要涉及虚拟地址空间的切换，而线程不会，虚拟地址空间切换后就会导致快表失效，重新进行查询的话就会导致效率下降，所以当计算量大的时候一般会采用多线程的方式防止频繁地切换浪费资源。
* 中断上下文切换
    * 为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其它进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行；即便中断过程打断了一个正在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。

## 5 同一个进程内的多个线程共享哪些信息，不共享哪些信息？
* 线程的栈区、程序计数器、栈指针以及函数运行使用的寄存器是线程私有的，统一称为线程上下文。有时候我们还可以使用TLS线程局部存储的技术，TLS表示存放在该区域中的变量是全局变量，所有线程都可以访问；虽然看上去所有线程访问的都是同一个变量，但这个全局变量独属于一个线程，一个线程对此变量的修改对其他线程不可见。
* 进程中的线程除了线程上下文信息以外其他的内容都是可以共享的，包括代码区（编译后的可执行机器指令，从可执行文件加载到内存的）、堆区、全局变量、静态变量。

## 6 什么时候需要上下文切换
* 在一些调度算法中，有的进程有时候要暂时离开CPU，例如时间片完或者资源不足，然后让另一个进程进来CPU运作，此时需要进行上下文切换。
* 中断处理：在接受到中断信息的时候，CPU必须要进行上下文切换。
* 内核态和用户态的转换。

## 7 进程PCB，进程控制块的内容
1. 程序ID（PID、进程句柄）：它是唯一的，一个进程都必须对应一个PID。PID一般是整形数字。
2. 特征信息：一般分系统进程、用户进程、或者内核进程等
3. 进程状态：运行、就绪、阻塞，表示进程现的运行情况
4. 优先级：表示获得CPU控制权的优先级大小
5. 通信信息：进程之间的通信关系的反映，由于操作系统会提供通信信道
6. 现场保护区：保护阻塞的进程用
7. 资源需求、分配控制信息
8. 进程实体信息，指明程序路径和名称，进程数据在物理内存还是在交换分区（分页）中
9. 其他信息：工作单位，工作区，文件信息等。

## 8 线程TCB，线程控制块的内容
1. threadID：线程的唯一标识。
2. status：线程的运行状态
3. register：线程关于CPU中寄存器的情况
4. PC程序计数器：线程执行的下一条指令的地址
5. 优先级：线程在操作系统调度的时候的优先级
6. 线程的专属存储区：线程单独的存储区域
7. 用户栈：线程执行的用户方法栈，用来保存线程当前执行的用户方法的信息
8. 内核栈：线程执行的内核方法栈，用来保存线程当前执行的内核方法信息

## 9 用户态和内核态的概念、优势、转换方式
* 内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡。CPU也可以将自己从一个程序切换到另一个程序。
* 用户态: 只能受限的访问内存, 且不允许访问外围设备。占用CPU的能力被剥夺, CPU资源可以被其他程序获取。
* 内核态和用户态的优势：运行在内核态的程序可以访问的资源多，但可靠性、安全性要求高，维护管理都较复杂；用户态程序程序访问的资源有限，但可靠性、安全性要求低，自然编写维护起来比较简单。一个程序到底应该运行在内核态还是用户态则取决于其对资源和效率的需求。

## 10 用户态转为内核态的三个方式：
* 系统调用：用户态进程主动切换到内核态的方式，用户态进程通过系统调用申请使用操作系统的提供的程序完成操作，系统调用本身就是中断。
* 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
* 外设中断：当外设完成用户的请求时，会向CPU发送中断信号。

## 11 用户空间和内核空间的内容

## 12 系统调用的概念及其过程
* 系统内核通过包装一些能够实现特定功能的特殊硬件指令和硬件状态，即我们所说的内核函数，通过一组系统调用的接口呈现给用户，平常我们的进程几乎都是用户态，读取用户数据，当涉及到系统级别资源的操作（例如文件管理、进程控制、内存管理等）的时候，就要用到系统调用了。
* 过程：当系统发起调用时通常通过一个陷阱(trap)特殊硬件指令，硬件将控制转移到预先指定的陷阱处理程序（trap handler）（即预先设置的操作系统），并同时将特权级别提升到内核模式。
* 在内核模式下，操作系统可以完全访问系统的硬件，因此可以执行诸如发起I/O请求或为程序提供更多内存等功能。
当操作系统完成请求的服务时，它通过特殊的陷阱返回（return-from-trap）指令将控制权交还给用户，该指令返回到用户态，同时将控制权交还给应用程序，回到应用离开的地方。
